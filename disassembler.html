<p>NES ROM <input onchange="with(f=new FileReader)readAsArrayBuffer(files[0]),onload=s"type=file>
<p>
<table border>
<th width=500>Code
<th width=256>Graphics
<tr>
<td><pre id=code>
<td style=vertical-align:top>
<canvas id=a width=256 height=1024></canvas>
</table>

<br>
<script>

// Init canvas
c = a.getContext("2d");

/*
opcodes = [
"BRK",
"ORA X,ind",
,
,
,
"ORA zpg",
"ASL zpg",
,
"PHP",
"ORA #",
"ASL A",
,
,
"ORA abs",
"ASL abs",
,
"BPL rel",
"ORA ind,Y",
,
,
,
"ORA zpg,X",
"ASL zpg,X",
,
"CLC",
"ORA abs,Y",
,
,
,
"ORA abs,X",
"ASL abs,X",
,
"JSR abs",
"AND X,ind",
,
,
"BIT zpg",
"AND zpg",
"ROL zpg",
,
"PLP",
"AND #",
"ROL A",
,
"BIT abs",
"AND abs",
"ROL abs",
,
"BMI rel",
"AND ind,Y",
,
,
,
"AND zpg,X",
"ROL zpg,X",
,
"SEC",
"AND abs,Y",
,
,
,
"AND abs,X",
"ROL abs,X",
,
"RTI",
"EOR X,ind",
,
,
,
"EOR zpg",
"LSR zpg",
,
"PHA",
"EOR #",
"LSR A",
,
"JMP abs",
"EOR abs",
"LSR abs",
,
"BVC rel",
"EOR ind,Y",
,
,
,
"EOR zpg,X",
"LSR zpg,X",
,
"CLI",
"EOR abs,Y",
,
,
,
"EOR abs,X",
"LSR abs,X",
,
"RTS",
"ADC X,ind",
,
,
,
"ADC zpg",
"ROR zpg",
,
"PLA",
"ADC #",
"ROR A",
,
"JMP ind",
"ADC abs",
"ROR abs",
,
"BVS rel",
"ADC ind,Y",
,
,
,
"ADC zpg,X",
"ROR zpg,X",
,
"SEI",
"ADC abs,Y",
,
,
,
"ADC abs,X",
"ROR abs,X",
,
,
"STA X,ind",
,
,
"STY zpg",
"STA zpg",
"STX zpg",
,
"DEY",
,
"TXA",
,
"STY abs",
"STA abs",
"STX abs",
,
"BCC rel",
"STA ind,Y",
,
,
"STY zpg,X",
"STA zpg,X",
"STX zpg,Y",
,
"TYA",
"STA abs,Y",
"TXS",
,
,
"STA abs,X",
,
,
"LDY #",
"LDA X,ind",
"LDX #",
,
"LDY zpg",
"LDA zpg",
"LDX zpg",
,
"TAY",
"LDA #",
"TAX",
,
"LDY abs",
"LDA abs",
"LDX abs",
,
"BCS rel",
"LDA ind,Y",
,
,
"LDY zpg,X",
"LDA zpg,X",
"LDX zpg,Y",
,
"CLV",
"LDA abs,Y",
"TSX",
,
"LDY abs,X",
"LDA abs,X",
"LDX abs,Y",
,
"CPY #",
"CMP X,ind",
,
,
"CPY zpg",
"CMP zpg",
"DEC zpg",
,
"INY",
"CMP #",
"DEX",
,
"CPY abs",
"CMP abs",
"DEC abs",
,
"BNE rel",
"CMP ind,Y",
,
,
,
"CMP zpg,X",
"DEC zpg,X",
,
"CLD",
"CMP abs,Y",
,
,
,
"CMP abs,X",
"DEC abs,X",
,
"CPX #",
"SBC X,ind",
,
,
"CPX zpg",
"SBC zpg",
"INC zpg",
,
"INX",
"SBC #",
"NOP",
,
"CPX abs",
"SBC abs",
"INC abs",
,
"BEQ rel",
"SBC ind,Y",
,
,
,
"SBC zpg,X",
"INC zpg,X",
,
"SED",
"SBC abs,Y",
,
,
,
"SBC abs,X",
"INC abs,X"
];
*/


// # = imm
// ~ = ind
// @ = abs
// $ = zpg 
// & = rel

// Opcodes list
opcodes = "BrkOra x,~???Ora$Asl$?PhpOra#Asl a??Ora@Asl@?Bpl&Ora~,y???Ora$,xAsl$,x?ClcOra@,y???Ora@,xAsl@,x?Jsr@And x,~??Bit$And$Rol$?PlpAnd#Rol a?Bit@And@Rol@?Bmi&And~,y???And$,xRol$,x?SecAnd@,y???And@,xRol@,x?RtiEor x,~???Eor$Lsr$?PhaEor#Lsr a?Jmp@Eor@Lsr@?Bvc&Eor~,y???Eor$,xLsr$,x?CliEor@,y???Eor@,xLsr@,x?RtsAdc x,~???Adc$Ror$?PlaAdc#Ror a?Jmp~Adc@Ror@?Bvs&Adc~,y???Adc$,xRor$,x?SeiAdc@,y???Adc@,xRor@,x??Sta x,~??Sty$Sta$Stx$?Dey?Txa?Sty@Sta@Stx@?Bcc&Sta~,y??Sty$,xSta$,xStx$,y?TyaSta@,yTxs??Sta@,x??Ldy#Lda x,~Ldx#?Ldy$Lda$Ldx$?TayLda#Tax?Ldy@Lda@Ldx@?Bcs&Lda~,y??Ldy$,xLda$,xLdx$,y?ClvLda@,yTsx?Ldy@,xLda@,xLdx@,y?Cpy#Cmp x,~??Cpy$Cmp$Dec$?InyCmp#Dex?Cpy@Cmp@Dec@?Bne&Cmp~,y???Cmp$,xDec$,x?CldCmp@,y???Cmp@,xDec@,x?Cpx#Sbc x,~??Cpx$Sbc$Inc$?InxSbc#Nop?Cpx@Sbc@Inc@?Beq&Sbc~,y???Sbc$,xInc$,x?SedBc@,y???Sbc@,xInc@,x?".split(/(?=[A-Z?])/)


// Process ROM Stored in z.
s = z => {

  
  // Make an array of bytes
  u = new Uint8Array(f.result);
  
  // Read number of 16kb program banks
  prg = u[4];
  prgaddress = prg ? 16 : 0x2000;
  prg = prg || 1;
  
  // Read number of 8kb graphics banks 
  chr = u[5];
  chraddress = chr ? 16 + 16 * 1024 * prg : 0x2000;
  chr = chr || 1;
  
  // Log banks sizes
  // console.log(`${prg} * 16kB ROM, ${chr} * 8kB VROM`);
  
  // Read main addresses
  h = code.innerHTML = "";
  h += "NMI: $" + (1e3 + ((u[0x800B] << 8) + u[0x800A]).toString(16)).slice(-4) + "\n";
  h += "Reset: $" + (1e3 + ((u[0x800D] << 8) + u[0x800C]).toString(16)).slice(-4) + "\n";
  h += "BRK: $" + (1e3 + ((u[0x800F] << 8) + u[0x800E]).toString(16)).slice(-4) + "\n\n";
  
  started = 0;
  
  // Write PRG address, bytes, asm
  for(i = prgaddress; i < prgaddress + prg * 16 * 1024; i++){
    
    // skip 0x00 padding
    if(u[i] == 0x00 && !started){
      continue;
    }
    else {
      started = 1;
    }
    
    addr = i;
    op = u[i];
    asm = opcodes[op] || "?";
    
    op = ((1e3)+op.toString(16)).slice(-2);
    
    // Convert "#" into immediate operand (1 byte) 
    if(asm.indexOf("#") > -1){
      op2 = u[++i];
      asm = asm.replace("#", " $" + ((1e3)+op2.toString(16)).slice(-2));
      op += " " + ((1e3)+op2.toString(16)).slice(-2) + "   ";
    }
    
    // Convert "$" into zpg address (1 byte)
    else if(asm.indexOf("$") > -1){
      op2 = u[++i];
      asm = asm.replace("$", " " + ((1e3)+op2.toString(16)).slice(-2));
      op += " " + ((1e3)+op2.toString(16)).slice(-2) + "   ";
    }
    
    // Convert "~" into ind address (1 byte)
    else if(asm.indexOf("~") > -1){
      op2 = u[++i];
      asm = asm.replace("~", " ${" + ((1e3)+op2.toString(16)).slice(-2) + "}");
      op += " " + ((1e3)+op2.toString(16)).slice(-2) + "   ";
    }
    
    // Convert "@" into absolute address (2 bytes)
    else if(asm.indexOf("@") > -1){
      op2 = u[++i];
      op3 = u[++i];
      val = ((op3 << 8) + op2);
      asm = asm.replace("@",  " $" + ((1e3) + val.toString(16)).slice(-4));
      op += " " + ((1e3) + op2.toString(16)).slice(-2) + " " + ((1e3)+op3.toString(16)).slice(-2);
    }
    
    // Convert "&" into relative address (1 byte)
    else if(asm.indexOf("&") > -1){
      op2 = u[++i];
      asm = asm.replace("&",  " $#" + ((1e3) + op2.toString(16)).slice(-2));
      op += " " + ((1e3) + op2.toString(16)).slice(-2) + "   ";
    }
    
    // Pad with spaces if no extra operand is used
    else {
      op += "      ";
    }
    
    h += ((1e3) + (addr - 16 + 0x8000).toString(16)).slice(-4) + " | " + op + " | " + asm;
    h += "\n";
  }
  
  code.innerHTML = h.toUpperCase().replace(/, /g, ",");
  
  
  // Prepare canvas
  a.height = chr * 1024;

  // Read tile (2 bytes)
  tile = 0;
  for(i = chraddress; i < chraddress + chr * 8 * 1024; i += 16){
    
    for(k = 0; k < 8; k++){
      b = u[i + k];
      bb = u[i + 8 + k];
      for(j = 0; j < 8; j++){
        b1 = ((b >> (7 - j)) & 1) * 2 + ((bb >> (7 - j)) & 1);
        c.fillStyle = ["#000","#555","#aaa","#fff"][b1];
        c.fillRect(
          (tile % 8) * 32 + j * 4, // x
          ((~~(tile / 8))) * 32 + k * 4, // y
          4, // w
          4 // h
        );
      }
    }
    tile++;
  }
  
  for(i=0;i<512;i++){
    c.fillStyle = "pink";
    c.fillRect(i*32-1,0,1,8200);
    c.fillRect(0,i*32-1,256,1);
  }
}

// Auto demo: Load SMB ROM And call s()
f = new XMLHttpRequest;
f.open('GET', "smb.nes");
f.responseType = 'arraybuffer';
f.send();
f.onload=function(){
  f.result = f.response;
  s();
};
</script>